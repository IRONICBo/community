import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"

	"github.com/goplus/community/internal/core"
	"github.com/goplus/community/translation"
	_ "github.com/joho/godotenv/autoload"
	"github.com/qiniu/x/xlog"
	language "golang.org/x/text/language"
	"time"
)

var (
	community *core.Community
	trans     *translation.Engine
)

const (
	layoutUS   = "January 2, 2006"
	limitConst = 10
)

todo := context.TODO()
endpoint := os.Getenv("GOP_COMMUNITY_ENDPOINT")
domain := os.Getenv("GOP_COMMUNITY_DOMAIN")
xLog := xlog.New("")

// Modify / to /static
// Support 404 handle
static "/static"

get "/success", ctx => {
	ctx.yap "2xx", {}
}

get "/error", ctx => {
	ctx.yap "4xx", {}
}

get "/failed", ctx => {
	ctx.yap "5xx", {}
}

get "/signin", ctx => {
	ctx.yap "signin", {}
}

// Home
get "/", ctx => {
	// Get User Info
	var user *core.User
	userId := ""
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		} else {
			userId = user.Id
		}
	}
	// Get Article Info
	articles, next, _ := community.ListArticle(todo, core.MarkBegin, limitConst, "")
	articlesJson, _ := json.Marshal(&articles)
	ctx.yap "home", {
		"UserId": userId,
		"User":   user,
		"Items":  strings.Replace(string(articlesJson), `\"`, `"`, -1),
		"Next":   next,
	}
}

// Article
//
// Article pages
get "/page/p/:id", ctx => {
	// todo middleware
	// Get User Info
	var user *core.User
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		}
	}

	id := ctx.param("id")
	article, _ := community.Article(todo, id)
	ctx.yap "article", {
		"User":    user,
		"ID":      id,
		"Title":   article.Title,
		"Content": article.Content,
		// "HtmlUrl": article.HtmlUrl,
		"Tags":    article.Tags,
		"Cover":   article.Cover,
		"Mtime":   article.Mtime.Format(layoutUS),
		"Author":  article.User,
		// "User": article.User,
	}
}

get "/page/add", ctx => {
	var user *core.User
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		}
	}
	ctx.yap "edit", {
		"User":        user,
	}
}

get "/page/edit/:id", ctx => {
	var user *core.User
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		}
	}

	uid := user.Id
	id := ctx.param("id")
	if id != "" {
		if editable, _ := community.CanEditable(todo, uid, id); !editable {
			xLog.Error("no permissions")
			http.Redirect(ctx.ResponseWriter, ctx.Request, "/error", http.StatusTemporaryRedirect)
		}
		article, _ := community.Article(todo, id)
		articleJson, _ := json.Marshal(&article)
		ctx.yap "edit", {
			"User":    user,
			"Article": strings.Replace(string(articleJson), `\"`, `"`, -1),
		}
	}
}

// Article
//
// Article apis
get "/api/article/:id", ctx => {
	id := ctx.param("id")
	article, _ := community.Article(todo, id)
	ctx.json {
		"code": 200,
		"data": article,
	}
}

delete "/api/article/:id", ctx => {
	id := ctx.param("id")
	token, err := core.GetToken(ctx)
	uid, err := community.ParseJwtToken(token.Value)
	if err != nil {
		xLog.Error("token parse error")
		ctx.json {
			"code": 0,
			"err":  err.Error(),
		}
	}
	err = community.DeleteArticle(todo, uid, id)
	if err != nil {
		ctx.json {
			"code": 0,
			"err":  "delete failed",
		}
	} else {
		ctx.json {
			"code": 200,
			"msg":  "delete success",
		}
	}
}

get "/api/articles", ctx => {
	from := ctx.param("from")
	limit := ctx.param("limit")
	searchValue := ctx.param("value")

	limitInt, err := strconv.Atoi(limit)
	if err != nil {
		limitInt = limitConst
	}
	// Get Article Info
	articles, next, _ := community.ListArticle(todo, from, limitInt, searchValue)
	ctx.json {
		"code":  200,
		"items": articles,
		"next":  next,
		"value": searchValue,
	}
}

get "/api/search", ctx => {
	searchValue := ctx.param("value")

	// todo middleware
	var user *core.User
	userId := ""
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		} else {
			userId = user.Id
		}
	}

	articles, next, _ := community.ListArticle(todo, core.MarkBegin, limitConst, searchValue)
	articlesJson, _ := json.Marshal(&articles)
	ctx.yap "home", {
		"UserId": userId,
		"User":   user,
		"Items":  strings.Replace(string(articlesJson), `\"`, `"`, -1),
		"Value":  searchValue,
		"Next":   next,
	}
}

post "/api/commit", ctx => {
	// Whether article has been translated or not
	// trans := ctx.param("trans") // if trans != ""ï¼Œ add article
	id := ctx.param("id")
	mdData := ctx.param("content")
	transData := ctx.param("trans_data")
	// get user id
	token, err := core.GetToken(ctx)
	if err != nil {
		xLog.Info("token",err)
		ctx.json {
			"code": 0,
			"err":  "no token",
		}
	}
	uid, err := community.ParseJwtToken(token.Value)
	if err != nil {
		xLog.Info("uid",err)
		ctx.json {
			"code": 0,
			"err":  err.Error(),
		}
	}
	// add article
	article := &core.Article{
		ArticleEntry: core.ArticleEntry{
			ID:       id,
			Title:    ctx.param("title"),
			UId:      uid,
			Cover:    ctx.param("cover"),   
			Tags:     ctx.param("tags"),
			Abstract: ctx.param("abstract"),
		},
		Content:  mdData,
		TransContent: transData,
	}
	id, _ = community.PutArticle(todo, uid, article)
	ctx.json {
		"code": 200,
		"data": id,
	}
}


// User
//
// User pages
get "/page/user/account", ctx => {
	var user *core.User
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		}
	}

	if err != nil {
		http.Redirect(ctx.ResponseWriter, ctx.Request, "/error", http.StatusTemporaryRedirect)
	}
	ctx.yap "user_account", {
		"User": user,
	}
}

get "/page/user/:id", ctx => {
	id := ctx.param("id")
	// Get current User Info by id
	userClaim, err := community.GetUserClaim(id)
	if err != nil {
		xLog.Error("get current user error:", err)
	}
	// todo middleware
	// get user by token
	var user *core.User
	token, err := core.GetToken(ctx)
	if err == nil {
		user, err = community.GetUser(token.Value)
		if err != nil {
			xLog.Error("get user error:", err)
		}
	}
	// get article list published by uid
	items, _ := community.GetArticlesByUid(todo, id)
	userClaimJson, _ := json.Marshal(&userClaim)
	itemsJson, _ := json.Marshal(&items)
	ctx.yap "user", {
		"Id":          id,
		"CurrentUser": strings.Replace(string(userClaimJson), `\"`, `"`, -1),
		"User":        user,
		"Items":       strings.Replace(string(itemsJson), `\"`, `"`, -1),
		"UserId":      user.Id,
	}
}

// User
//
// User apis

// Media
//
// Media apis
get "/api/medias", ctx => {
	format := ctx.param("format")
	uid := ctx.param("uid")
	files, err := community.ListMediaByUserId(todo, uid, format)
	if err != nil {
		ctx.json {
			"code": 0,
			"err":  "get media failed",
		}
	} else {
		ctx.json {
			"code":  200,
			"items": files,
		}
	}
}

delete "/api/medias/:id", ctx => {
	id := ctx.param("id")
	token, err := core.GetToken(ctx)
	uid, err := community.ParseJwtToken(token.Value)
	if err != nil {
		xLog.Error("token parse error")
		ctx.json {
			"code": 0,
			"err":  err.Error(),
		}
	}
	err = community.DelMedia(todo, uid, id)
	if err != nil {
		ctx.json {
			"code": 0,
			"err":  "delete failed",
		}
	} else {
		ctx.json {
			"code": 200,
			"msg":  "delete success",
		}
	}
}


get "/api/translations/:id", ctx => {
	id := ctx.param("id")
	htmlUrl, err := community.TransHtmlUrl(todo, id)
	if err != nil {
		ctx.json {
			"code": 500,
			"err":  err.Error(),
		}
	}
	ctx.json {
		"code": 200,
		"data": htmlUrl,
	}
}

post "/api/translations", ctx => {
	// get user id
	// token, err := core.GetToken(ctx)
	// if err != nil {
	// 	ctx.json {
	// 		"code": 500,
	// 		"err":  "no token",
	// 	}
	// }
	// uid, err := community.ParseJwtToken(token.Value)
	// if err != nil {
	// 	ctx.json {
	// 		"code": 500,
	// 		"err":  err.Error(),
	// 	}
	// }
	// uid := "70f6a615-c0d5-4315-a5ac-34ca845450ed"
	mdData := ctx.param("content")
	// htmlData := ctx.param("html")
	// id := ctx.param("id")
	// get translation markdown
	transData, err := community.TranslateMarkdownText(todo, mdData, language.Chinese, language.English)
	if err != nil {
		ctx.json {
			"code": 500,
			"err":  err.Error(),
		}
	}
	ctx.json {
		"code": 200,
		"data": transData, // translation markdown content
	}
	// id, _ = community.SaveHtml(todo, uid, htmlData, mdData, id)
	// ctx.json {
	// 	"code": 200,
	// 	"id":   id,        //article id
	// 	"data": transData, // translation markdown content
	// }
}

get "/api/medias/url/:id", ctx => {
	id := ctx.param("id")
	fileKey, err := community.GetMediaUrl(todo, id)
	htmlUrl := fmt.Sprintf("%s%s", domain, fileKey)
	if err != nil {
		ctx.json {
			"code": 500,
			"err":  "have no html media",
		}
	}
	ctx.json {
		"code": 200,
		"url":  htmlUrl,
	}
}

get "/api/video-with-caption/:id", ctx => {
	// TODO: Just to test sync, please remove later
	time.Sleep(5*time.Second)
	id := ctx.param("id")
	fileKey, err := community.GetMediaUrl(todo, id)
	m:=make(map[string]string,2)
	format,err:=community.GetMediaType(todo,id)
	if err!=nil {
		ctx.json {
			"code": 500,
			"err":  err.Error(),
		}
	}
	if format == "video/mp4" {
	    subtitle,err:=community.GetVideoSubtitle(todo,id)
	    if err!=nil{
	        if err != nil {
            	ctx.json {
            		"code": 500,
            		"err":  err.Error(),
            		}
            	}
            return
	    }
        m["subtitle"] = domain+subtitle
	}
	htmlUrl := fmt.Sprintf("%s%s", domain, fileKey)
	if err != nil {
		ctx.json {
			"code": 500,
			"err":  "have no html media",
		}
	}
	m["fileKey"] = htmlUrl
	ctx.json {
		"code": 200,
		"url":  m,
	}
}

post "/api/medias", ctx => {
	community.UploadFile(ctx)
}

// Account
//
// Account apis
get "/api/login", ctx => {
	// Get URL from query string
	// redirectURL := ctx.URL.Query().Get("redirect_url")
	// Get current request page URL from
	// Concatenate the current request page URL from refer
	refererURL, err := url.Parse(ctx.Request.Referer())
	if err != nil {
		xLog.Info("Error parsing Referer: %v", err)
		return
	}

	refererPath := refererURL.Path
	if refererURL.RawQuery != "" {
		refererPath = fmt.Sprintf("%s?%s", refererURL.Path, refererURL.RawQuery)
	}

	redirectURL := fmt.Sprintf("%s://%s/%s?origin_path=%s", refererURL.Scheme, refererURL.Host, "callback", url.QueryEscape(refererPath))

	loginURL := community.RedirectToCasdoor(redirectURL)
	ctx.Redirect loginURL, http.StatusFound
}

get "/api/logout", ctx => {
	err := core.RemoveToken(ctx)
	if err != nil {
		xLog.Error("remove token error:", err)
	}

	refererURL, err := url.Parse(ctx.Request.Referer())
	if err != nil {
		xLog.Info("Error parsing Referer: %v", err)
		return
	}

	refererPath := refererURL.Path
	if refererURL.RawQuery != "" {
		refererPath = fmt.Sprintf("%s?%s", refererURL.Path, refererURL.RawQuery)
	}

	http.Redirect(ctx.ResponseWriter, ctx.Request, refererPath, http.StatusFound)
}

get "/api/callback", ctx => {
	err := core.SetToken(ctx)
	if err != nil {
		xLog.Error("set token error:", err)
	}
	origin_path := ctx.URL.Query().Get("origin_path")
	unurl, err := url.QueryUnescape(origin_path)
	if err != nil {
		xLog.Info("Unurl error",err)
		unurl = "/"
	}

	http.Redirect(ctx.ResponseWriter, ctx.Request, unurl, http.StatusFound)
}

conf := &core.Config{}
community, _ = core.New(todo, conf)
core.CasdoorConfigInit()

// 404
handle "/", ctx => {
	ctx.yap "4xx", {}
}

xLog.Info "Started in endpoint: ", endpoint

// 500
run(endpoint, func(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func() {
			if err := recover(); err != nil {
				http.Redirect(w, r, "/failed", http.StatusFound)
			}
		}()

		h.ServeHTTP(w, r)
	})
})
